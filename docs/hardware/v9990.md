# Yamaha V9990 (E-VDP-III) — External Graphics Processor for CPC

## Overview

The **Yamaha V9990** (catalog LSI-2499903, 1992) is a standalone video display processor designed for games, audio-visual, and office applications. It was the last of Yamaha's VDP line (V9938 → V9958 → V9990) and never shipped inside a standard computer — instead it appeared on expansion cards for the MSX (Sunrise **GFX9000**, Tecnobytes **Powergraph**) and for the CPC (TMTLogic **GFX-NINE**).

The V9990 gives the CPC capabilities that are completely alien to its native Gate Array:

| Capability | CPC Gate Array | V9990 |
|-----------|---------------|-------|
| Max resolution | 640×200 (Mode 2) | 768×480 (B4 interlaced) |
| Colours on screen | 16 (Mode 0) | 32,768 (15-bit, BD16) |
| Palette entries | 27 hardwired | 64 from 32,768 |
| Sprites | 0 (Plus: 16) | 125 per screen, 16×16 |
| Hardware scrolling | None | Omnidirectional, per-plane |
| Hardware blitter | None | 15 commands (LMMM, LINE, etc.) |
| VRAM | 16KB (shared with CPU) | Up to 512KB dedicated |
| Colour modes | Fixed per mode | PP, BYUV, BYJK, BD16, BD8, BP6, BP4, BP2 |

The V9990 has its own clock (21MHz crystal or 14MHz MCKIN), its own VRAM bus, its own DAC, and its own RGB output. From the CPC's perspective it's an intelligent peripheral — the Z80 talks to it through 16 I/O ports, writing registers and VRAM data, issuing hardware drawing commands, and reading back status.

---

## 1. Block Diagram

```
                    ┌────────────────────────────────────────────────┐
                    │                    V9990                       │
                    │                                                │
   Z80 ◄──────────►│  CPU INTERFACE     ┌──────────┐               │
   CD7-0 (data)     │  (P#0..P#F)  ────►│ TG/CRTC  │──► HSYNC/CSYNC│
   MODE3-0 (addr)   │                   └──────────┘               │
   *CSR, *CSW        │       │                                      │
   *WAIT             │       ├──────────►┌──────────┐  ┌─────┐     │
   *INT1, *INT0      │       │           │ LUT/YJK  │─►│ DAC │──►RGB│
                    │       │           │  PANEL   │  └─────┘     │
                    │       ├──────────►┌──────────┐               │
                    │       │           │  SPRITE  │               │
                    │       │           └──────────┘               │
                    │       ├──────────►┌──────────┐               │
                    │       │           │ DISPLAY  │               │
                    │       │           └──────────┘               │
                    │       ├──────────►┌──────────┐               │
                    │       │           │ BLITTER  │               │
                    │       │           │(Cmd Eng) │               │
                    │       │           └──────────┘               │
                    │       │                   │                   │
                    │       └───────────────────┼──► VRAM INTERFACE │
                    │                           │                   │
                    └───────────────────────────┼───────────────────┘
                                                │
                              ┌──────────┐  ┌──────────┐
                              │  VRAM    │  │ KANJI ROM│
                              │128-512KB │  │  2Mbit   │
                              └──────────┘  └──────────┘
```

Key subsystems:
- **CPU Interface** — 16 I/O ports (P#0–P#F), directly addressed by MODE3-0 pins
- **TG/CRTC** — Timing Generator, produces HSYNC/VSYNC/blanking, configurable for NTSC/PAL
- **Display** — Fetches pattern or bitmap data from VRAM, applies scroll offsets
- **Sprite** — 125 hardware sprites (16×16), 16 per scanline, 4 palettes of 16 colours
- **Blitter (Command Engine)** — 15 hardware drawing commands operating directly on VRAM
- **LUT/YJK Panel** — Colour lookup tables, YUV/YJK decoding, superimposition
- **DAC** — Built-in digital-to-analogue converter, linear 5-bit RGB output
- **VRAM Interface** — Dual-port DRAM controller for up to 512KB

---

## 2. Pin Assignment (128-pin QFP)

### CPU Interface Pins

| Pin | Name | Dir | Function |
|-----|------|-----|----------|
| 119-122 | CD7-CD4 | I/O | CPU data bus (high nibble) |
| 116-114 | CD3-CD1 | I/O | CPU data bus |
| ~~113~~ | CD0 | I/O | CPU data bus (LSB) — **⚠ pin number unverified, conflicts with MCKIN below** |
| 4-7 | MODE0-MODE3 | I | I/O port address select (selects P#0–P#F) |
| 3 | *CSR | I | Chip Select Read (active low) — VDP outputs data to CD7-0 |
| 2 | *CSW | I | Chip Select Write (active low) — D7-0 latched on rising edge |
| 1 | *WAIT | O (OD) | Wait signal to CPU — active while VDP busy with read/write |
| 127 | *INT1 | O (OD) | Interrupt: display position reached |
| 126 | *INT0 | O (OD) | Interrupt: vertical retrace / command end |
| 125 | *DREQ | O (OD) | Data request during command execution |
| 124 | *VMREQ | I | Direct VRAM access request from CPU (bypassing VDP) |

### Clock Pins

| Pin | Name | Dir | Function |
|-----|------|-----|----------|
| 98-99 | XTAL1, XTAL2 | I | 21.477 MHz crystal oscillator |
| ~~113~~ | MCKIN | I | 14.318 MHz master clock input (alternative to XTAL) — **⚠ pin number conflicts with CD0 above; one is wrong — needs re-verification from datasheet pinout diagram** |
| 111-112 | DHCLK, DLCLK | O | Dot clock outputs: DHCLK=MCK/2, DLCLK=MCK/4 |

### VRAM Interface Pins

| Pin | Name | Dir | Function |
|-----|------|-----|----------|
| 18-26 | V0A8-V0A0 / KA8-KA0 | O (3-state) | VRAM0 address bus / Kanji ROM address |
| 28-35 | V0D7-V0D0 / KD7-KD0 | I/O | VRAM0 data bus / Kanji ROM data |
| 71-80 | V1A8-V1A0 | O (3-state) | VRAM1 address bus |
| 82-90 | V1D7-V1D0 | I/O | VRAM1 data bus |
| 37 | *V0RAS | O | VRAM0 Row Address Strobe |
| 38 | *V0CAS | O | VRAM0 Column Address Strobe |
| 62-63 | *V1RAS, *V1CAS | O | VRAM1 Row/Column Address Strobe |

### CRT Output Pins

| Pin | Name | Dir | Function |
|-----|------|-----|----------|
| 100 | *HSYNC/LC | O | Horizontal sync (CRT) / Latch clock (panel) |
| 102 | *CSYNC/FLM | O | Composite sync (CRT) / Frame start (panel) |
| 103 | *BLANK/M | O | Blanking interval signal |
| 91-95 | R, G, B, *YS, CB | O | Analogue RGB + superimpose + colour bus |

---

## 3. I/O Port Map

The V9990 presents 16 I/O ports, selected by the MODE3-0 input pins. On the CPC, these would be decoded to 16 consecutive addresses in the expansion I/O space.

> *Source: Datasheet §7 (Basic I/O operations) + OpenMSX `PortId` enum (P#0-P#F, verified exact match).*

| Port | Name | R/W | Function |
|------|------|-----|----------|
| **P#0** | VRAM Data | R/W | Read/write VRAM at current address pointer |
| **P#1** | Palette Data | R/W | Read/write palette RAM (auto-increment R→G→B) |
| **P#2** | Command Data | W | Data transfer port for blitter commands (LMMC, etc.) |
| **P#3** | Register Data | R/W | Read/write the register selected by P#4 |
| **P#4** | Register Select | W | Select register number (R#N) + auto-increment flags |
| **P#5** | Status | R | Status register (TR, VR, HR, CE, BD, etc.) |
| **P#6** | Interrupt Flag | R/W | Read: interrupt cause / Write: clear interrupt bits |
| **P#7** | System Control | W | b1: system reset (1=reset), b0: clock select (0=XTAL, 1=MCKIN) |
| **P#8** | Kanji ROM Low | W | Kanji font lower address byte |
| **P#9** | Kanji ROM High/Data | W/R | Write: upper address / Read: font data (32 reads per char) |
| **P#A** | Kanji ROM Low 2 | W | Secondary kanji (JIS level 2) lower address |
| **P#B** | Kanji ROM High/Data 2 | W/R | Secondary kanji upper/data |
| **P#C-P#F** | Reserved | — | Unused |

### Register Select (P#4) Bit Format

```
b7    b6    b5-b0
WII   RII   Register No. (R#N)
 │     │
 │     └─ Read Increment Inhibit: if 1, reading P#3 does NOT auto-increment
 └─── Write Increment Inhibit: if 1, writing P#3 does NOT auto-increment
```

When WII=0 and RII=0, the register pointer auto-increments after every read or write to P#3 — this allows burst-programming multiple consecutive registers.

> *Source: OpenMSX `writeIO(REGISTER_DATA)` — increment inhibited when `regSelect & 0x80` (WII). `readIO(REGISTER_DATA)` — increment inhibited when `regSelect & 0x40` (RII). Verified on real V9990.*

---

## 4. Register Map

### Control Registers (R#0 – R#28)

> *Source: Register names and numbers confirmed by OpenMSX `RegisterId` enum. Access modes (R/W) from OpenMSX `regAccess[]` table. Write masks from `regWriteMask[]` array (verified by writing 0xFF and reading back on real V9990).*

| Reg | Name | Bits | Function |
|-----|------|------|----------|
| **R#0** | VRAM Write Address Low | 7-0 | VRAM write pointer bits 7-0 (W only) |
| **R#1** | VRAM Write Address Mid | 7-0 | VRAM write pointer bits 15-8 (W only) |
| **R#2** | VRAM Write Address High | 7: AII, 2-0: addr 18-16 | Bit 7 = Address Increment Inhibit (W only; **write triggers pointer latch**) |
| **R#3** | VRAM Read Address Low | 7-0 | VRAM read pointer bits 7-0 (W only) |
| **R#4** | VRAM Read Address Mid | 7-0 | VRAM read pointer bits 15-8 (W only) |
| **R#5** | VRAM Read Address High | 7: AII, 2-0: addr 18-16 | Bit 7 = Address Increment Inhibit (W only; **write triggers pointer latch + prefetch**) |
| **R#6** | Screen Mode 0 | 7-6: DSPM, 5-4: DCKM, 3-2: XIMM, 1-0: CLRM | Display mode + image width + colour depth (R/W, mask &FF) |
| **R#7** | Screen Mode 1 | 7: HSCN, 6: C25, 5: SM1, 4: SM, 3: PAL, 2: EO, 1: IL, 0: YSE | Scan freq, overscan, PAL, interlace (R/W, mask &FF) |
| **R#8** | Control | 7: DISP, 6: SPD, 5: YSE, 4: VWTE, 3: VWM, 2-0: reserved | Display enable (**latched at frame start**), sprite disable (0=on, 1=off), superimpose (R/W, mask &FF) |
| **R#9** | Interrupt 0 | 7-0 | Interrupt line bits 7-0 |
| **R#10** | Interrupt 1 | 1-0 | Interrupt line bits 9-8 |
| **R#11** | Interrupt 2 | 2-0 | Interrupt enable: b2=CE, b1=HI, b0=VI |
| **R#12** | Interrupt 3 | 3-0 | Interrupt vertical offset |
| **R#13** | Palette Control | 7-6: colour mode, 5-4: unused, 3-0: palette offset | Palette type + offset (W only) |
| **R#14** | Palette Pointer | 7-2: palette No., 1-0: RGB counter | Which entry to access via P#1 (W only) |
| **R#15** | Back Drop Color | 5-0 | Border/backdrop colour index |
| **R#16** | Display Adjust | 7-4: vertical, 3-0: horizontal | Fine-tune display position |
| **R#17** | Scroll AY0 | 7-0 | Scroll A vertical low byte |
| **R#18** | Scroll AY1 | 7-6: roll mask, 5-0: AY high | Scroll A vertical high + roll control |
| **R#19** | Scroll AX0 | 7-0 | Scroll A horizontal low byte |
| **R#20** | Scroll AX1 | 2-0 | Scroll A horizontal high bits |
| **R#21** | Scroll BY0 | 7-0 | Scroll B vertical low byte (P1 only) |
| **R#22** | Scroll BY1 | 5-0 | Scroll B vertical high byte |
| **R#23** | Scroll BX0 | 7-0 | Scroll B horizontal low byte (P1 only) |
| **R#24** | Scroll BX1 | 2-0 | Scroll B horizontal high bits |
| **R#25** | Sprite Pattern Addr | 3-0 | Sprite pattern generator base address |
| **R#26** | LCD Control | 7-0 | LCD panel timing control |
| **R#27** | Priority Control | 3-2: Y split, 1-0: X split | Priority switching position |
| **R#28** | Sprite Palette Control | 5-0 | Sprite palette offset |

### Command Registers (R#32 – R#54)

| Reg | Name | Bits | Function |
|-----|------|------|----------|
| **R#32** | SX Low | 7-0 | Source X coordinate bits 7-0 |
| **R#33** | SX High | 2-0 | Source X bits 10-8 |
| **R#34** | SY Low | 7-0 | Source Y coordinate bits 7-0 |
| **R#35** | SY High | 3-0 | Source Y bits 11-8 |
| **R#36** | DX Low | 7-0 | Destination X bits 7-0 |
| **R#37** | DX High | 2-0 | Destination X bits 10-8 |
| **R#38** | DY Low | 7-0 | Destination Y bits 7-0 |
| **R#39** | DY High | 3-0 | Destination Y bits 11-8 |
| **R#40** | NX Low | 7-0 | Width (number of dots X) bits 7-0 |
| **R#41** | NX High | 2-0 | Width bits 10-8 |
| **R#42** | NY Low | 7-0 | Height (number of dots Y) bits 7-0 |
| **R#43** | NY High | 3-0 | Height bits 11-8 |
| **R#44** | Argument | Various | Direction flags, MXS/MXD (VRAM page select) |
| **R#45** | Log Op | 3-0 | Logical operation (0=none, 1-12 = AND/OR/XOR/NOT variants) |
| **R#46** | Write Mask Low | 7-0 | Write mask bits 7-0 |
| **R#47** | Write Mask High | 7-0 | Write mask bits 15-8 |
| **R#48** | Font Color FC0 | 7-0 | Foreground colour low |
| **R#49** | Font Color FC1 | 7-0 | Foreground colour high |
| **R#50** | Font Color BC0 | 7-0 | Background colour low |
| **R#51** | Font Color BC1 | 7-0 | Background colour high |
| **R#52** | Opcode | 7-4: pixel format, 3-0: CMD | Command to execute (trigger on write) |
| **R#53** | Border X Low | 7-0 | SRCH border X coordinate low |
| **R#54** | Border X High | 2-0 | SRCH border X high |

---

## 5. Screen Mode Register (R#6) — Display Mode Selection

R#6 is the master mode selector. Its four fields choose everything about the display. Changes to R#6 (and R#7) take effect at the **start of the next scanline**, not immediately.

> *Source: OpenMSX `writeRegister(SCREEN_MODE_0)` — calls `syncAtNextLine(syncSetMode, time)`, deferring mode change to next line.*

```
b7  b6 │ b5  b4 │ b3  b2 │ b1  b0
 DSPM  │  DCKM  │  XIMM  │  CLRM
       │        │        │
       │        │        └─ Colour depth: 00=2bpp, 01=4bpp, 10=8bpp, 11=16bpp
       │        └───── Image width (Bx only): 00=256, 01=512, 10=1024, 11=2048
       └──── Dot clock: 00=DLCLK (÷4), 01=DHCLK (÷2), 10=undivided (÷1), 11=invalid
 Display type:
   00 = P1 (Pattern, 256×212, 2 screens)
   01 = P2 (Pattern, 512×212, 1 screen)
   10 = Bx (Bitmap — actual mode depends on DCKM)
   11 = Standby (display off)
```

### Display Mode Summary

#### Pattern Modes (P1, P2)

| Property | P1 | P2 |
|----------|----|----|
| Master clock | 21.5 MHz | 21.5 MHz |
| Dot clock | 5.4 MHz (DLCLK) | 10.7 MHz (DHCLK) |
| Resolution | 256×212 | 512×212 |
| Screens | 2 (A+B, independent scroll) | 1 |
| Pattern size | 8×8 dots | 8×8 dots |
| Colours/pattern | 15 + clear | 15 + clear |
| Palettes | 4 × 16 colours from 32,768 | 4 × 16 colours from 32,768 |
| Pattern space | 32×26.5 patterns (display), 64×64 (image) | 64×26.5 patterns, 128×64 (image) |
| Max patterns | 16,384 | 16,384 |
| Sprites | 125 per screen, 16/line | 125 per screen, 16/line |

#### Bitmap Modes (B0–B7)

The bitmap mode is selected by DSPM=10 (Bx) in R#6. The DCKM field (R#6 bits 5-4) selects the dot clock divisor, and the P#7 System Control port bit 0 selects the master clock source (XTAL vs MCKIN). The combination produces the final mode:

| DCKM | P#7 b0=0 (XTAL) | P#7 b0=1 (MCKIN) | Dot clock divisor |
|------|------------------|-------------------|-------------------|
| 00 | B1 (5.37 MHz) | B0 (3.58 MHz) | ÷4 (DLCLK) |
| 01 | B3 (10.7 MHz) | B2 (7.16 MHz) | ÷2 (DHCLK) |
| 10 | B7 (21.5 MHz) | B4 (14.3 MHz) | ÷1 (undivided) |
| 11 | (invalid) | (invalid) | — |

> *Source: OpenMSX `V9990::calcDisplayMode()` — `status & 0x04` selects MCLK/XTAL, `regs[SCREEN_MODE_0] & 0x30` selects DCKM. Confirmed against datasheet §8.2.*

| Mode | Dot Clock | H Cycle | Resolution | Overscan | Notes |
|------|-----------|---------|------------|----------|-------|
| **B0** | 3.58 MHz | 15.7 KHz (NTSC) | 192×212 | Yes | MCKIN variant of B1 |
| **B1** | 5.37 MHz | 15.7 KHz (NTSC) | 256×212 | No | Standard bitmap |
| **B2** | 7.16 MHz | 15.7 KHz (NTSC) | 384×240 | Yes | MCKIN variant of B3 |
| **B3** | 10.7 MHz | 15.7 KHz (NTSC) | 512×212 | No | Hi-res bitmap |
| **B4** | 14.3 MHz | 15.7 KHz (NTSC) | 768×240 | Yes | MCKIN variant of B7 |
| **B5** | 21.5 MHz | 25.3 KHz | 640×400 | No | VGA-class (OA mode) |
| **B6** | 25.2 MHz | 31.5 KHz | 640×480 | No | VGA-class (OA mode) |
| **B7** | 21.5 MHz | 15.7 KHz (NTSC) | 1280×212 | No | Undivided XTAL clock |

> *Note: B0/B2/B4 appear on GFX9000 when MCKIN (14.318 MHz) is the master clock. B1/B3/B7 use the XTAL crystal (21.477 MHz). B5/B6 use separate higher-frequency timing (OA modes). The datasheet §8.2 bitmap mode table lists modes by dot clock frequency; the B0/B2/B4 vs B1/B3/B7 distinction arises from the P#7 clock source selection.*

#### Colour Depth vs Image Size (128KB VRAM)

Each bitmap mode supports multiple colour depths, trading colours for image size:

| Bits/Pixel | Colours | Image sizes (128KB VRAM) |
|------------|---------|--------------------------|
| 16 bpp | 32,768 | 256×256 |
| 8 bpp | 256 | 256×512, 512×256 |
| 4 bpp | 16 | 256×1024, 512×512, 1024×256 |
| 2 bpp | 4 | 256×2048, 512×1024, 1024×512, 2048×256 |

With 512KB VRAM, all image sizes quadruple.

---

## 6. Colour System

The V9990 supports multiple palette/colour modes, selected by R#13 (Palette Control):

### Colour Modes and Selection

The colour mode depends on the display mode (P1/P2 vs Bx) and the CLRM field of R#6 plus the R#13 Palette Control register:

**P1/P2 pattern modes**: Always use BP4 (4bpp palette mode, 16 colours per tile from palette).

**Bitmap modes**: Selected by R#6 CLRM and R#13 bits 7-6:

| CLRM (R#6 b1-0) | R#13 b7-6 | Mode | Description |
|------------------|-----------|------|-------------|
| 00 | — | BP2 | 2bpp palette (4 colours from 64) |
| 01 | — | BP4 | 4bpp palette (16 colours from 64) |
| 10 | 00 | BP6 | 6bpp palette (64 colours from 32,768) |
| 10 | 01 | BD8 | 8bpp direct (256 colours: 3R+3G+2B) |
| 10 | 10 | BYJK | YJK encoding (4 pixels share J,K; MSX2+ compatible) |
| 10 | 11 | BYUV | YUV encoding (5Y+5U+5V per pixel) |
| 11 | — | BD16 | 16bpp direct (32,768 colours: 5R+5G+5B) |

> *Source: OpenMSX `V9990::getColorMode()` — exact switch on `regs[SCREEN_MODE_0] & 0x03` and `pal_ctrl & 0xC0`. Pattern modes forced to BP4 by `!(regs[SCREEN_MODE_0] & 0x80)` check.*

Summary of all colour modes:

| Mode | Abbrev | Colours | Description |
|------|--------|---------|-------------|
| BP2 | Bitmap Palette 2 | 4 from 32,768 | 2-bit indexed through palette |
| BP4 | Bitmap Palette 4 | 16 from 32,768 | 4-bit indexed through palette |
| BP6 | Bitmap Palette 6 | 64 from 32,768 | 6-bit indexed through palette |
| BD8 | Bitmap Direct 8 | 256 | Direct 8-bit colour (3R+3G+2B) |
| BYJK | Bitmap YJK | 19,268 | MSX2+ compatible YJK encoding (4 pixels share J,K) |
| BYUV | Bitmap YUV | 32,768 | Direct: 5-bit Y, 5-bit U, 5-bit V per pixel |
| BD16 | Bitmap Direct 16 | 32,768 | Direct 15-bit colour per pixel (5R+5G+5B) |

### Palette RAM

- 64 entries, addressed with 4-byte stride (R, G, B, unused)
- RED byte: bit 7 = **YS** (superimpose) flag, bits 6-5 = masked to 0, bits 4-0 = 5-bit red (0-31)
- GREEN byte: bits 4-0 = 5-bit green (0-31), bits 7-5 = masked to 0
- BLUE byte: bits 4-0 = 5-bit blue (0-31), bits 7-5 = masked to 0
- 4th byte: always 0 (unused, skipped by auto-increment)
- Write masks: RED = `&9F` (10011111), GREEN = `&1F`, BLUE = `&1F`

> *Source: OpenMSX `writePaletteRegister()` — `case 0: val &= 0x9F`, `getPalette()` — `palette[4*index+0] & 0x80` for YS, `& 0x1F` for red value. Confirmed by palette init: `palette[4*i+0] = 0x9F`.*

### Palette Access Protocol (via P#1)

```
1. Write R#14 with: [palette_no << 2 | 0]  (select entry, reset RGB counter)
2. Write P#1: RED data   (bit 7 = YS flag, bits 4-0 = red value)
3. Write P#1: GREEN data (bits 4-0 = green value)
4. Write P#1: BLUE data  (bits 4-0 = blue value)
   — counter advances past unused 4th byte to next entry's RED
```

The ternary counter (R→G→B) cycles automatically. After BLUE (counter=2), the pointer advances by 2 (skipping the unused 4th byte), allowing burst writes of entire palettes.

---

## 7. VRAM Access

### Address Space

The VRAM address is 19 bits wide (0x00000 – 0x7FFFF = 512KB). The address is split across three register pairs:

- **Write**: R#0 (low), R#1 (mid), R#2 (high + AII flag)
- **Read**: R#3 (low), R#4 (mid), R#5 (high + AII flag)

### Write Sequence

```
1. Set P#4 = 0x00        (select R#0, auto-increment on)
2. Write P#3 = addr[7:0]  (R#0 set)
3. Write P#3 = addr[15:8] (R#1 set, auto-incremented)
4. Write P#3 = addr[18:16] | (AII << 7)  (R#2 set; only bits 2-0 are address, bit 7 is AII)
5. Write P#0 = data       (VRAM write, address auto-increments if AII=0)
6. Write P#0 = data       (next byte...)
```

### Read Sequence

```
1. Set P#4 = 0x03        (select R#3, auto-increment on)
2. Write P#3 = addr[7:0]  (R#3 set)
3. Write P#3 = addr[15:8] (R#4 set)
4. Write P#3 = addr[18:16] | (AII << 7)  (R#5 set)
5. Read P#0 = data        (first read returns pre-fetched byte, triggers next fetch)
```

**Important**: The first read after setting the address returns stale data (the pre-fetch buffer). Discard it or account for the 1-byte offset.

---

## 8. Command Engine (Hardware Blitter)

The V9990's command engine is a hardware 2D drawing accelerator. It operates directly on VRAM using X,Y coordinates, understanding the pixel layout of the current display mode.

### Command Opcodes (R#52)

R#52 byte format:

```
b7  b6  b5  b4 │ b3  b2  b1  b0
  Pixel Format  │    Command ID
                │
                └─ 0=STOP, 1=LMMC, 2=LMMV, ... F=ADVANCE
  Pixel mode for command execution:
    0 = P1,  1 = P2,  2 = Bpp2,  3 = Bpp4,  4 = Bpp8,  5 = Bpp16
    6-F = not used
```

> *Source: OpenMSX `V9990CmdEngine::setCmdReg()` dispatch — e.g. LMMV matches `case 0x02: case 0x12: case 0x22: case 0x32: case 0x42: case 0x52:`. Low nibble = command, high nibble = pixel format. This is DIFFERENT from the V9938/V9958 where the command is in the HIGH nibble.*

| CMD (bits 3-0) | Name | Function |
|----------------|------|----------|
| 0x0 | STOP | Abort current command |
| 0x1 | LMMC | Logical Move CPU → VRAM (CPU sends pixel data) |
| 0x2 | LMMV | Logical Move VRAM fill (fill rectangle with colour) |
| 0x3 | LMCM | Logical Move VRAM → CPU (read rectangle to CPU) |
| 0x4 | LMMM | Logical Move VRAM → VRAM (copy rectangle) |
| 0x5 | CMMC | CPU → VRAM character (1bpp font data from CPU, expanded with FC/BC) |
| 0x6 | CMMK | Kanji ROM → VRAM (render kanji character) |
| 0x7 | CMMM | VRAM → VRAM character (1bpp source, colour-expanded) |
| 0x8 | BMXL | Bitmap transfer external → VRAM (linear address source) |
| 0x9 | BMLX | Bitmap transfer VRAM → external (linear address dest) |
| 0xA | BMLL | Bitmap transfer linear → linear (byte-addressed copy) |
| 0xB | LINE | Draw line (Bresenham) |
| 0xC | SRCH | Search for colour boundary |
| 0xD | POINT | Read pixel colour at coordinate |
| 0xE | PSET | Write single pixel at coordinate |
| 0xF | ADVANCE | Advance cursor position |

### Logical Operations (R#45)

R#45 format: bit 4 = **TP** (transparent), bits 3-0 = **LO** (logical operation).

The 4-bit LO field encodes one of 16 standard binary boolean functions, applied bitwise per pixel between source (SC) and destination (DC). The truth table for LO value `n` is:

```
Bit 0 of n: result when SC=0, DC=0
Bit 1 of n: result when SC=0, DC=1
Bit 2 of n: result when SC=1, DC=0
Bit 3 of n: result when SC=1, DC=1
```

Common operations:

| LO | Binary | Operation | Description |
|----|--------|-----------|-------------|
| 0 | 0000 | DC=0 | Clear destination |
| 3 | 0011 | DC=DC | Keep destination (no-op) |
| 5 | 0101 | DC=DC | Keep destination |
| 8 | 1000 | DC=SC AND DC | AND |
| 10 | 1010 | DC=SC | Direct copy (destination = source) |
| 12 | 1100 | DC=NOT SC | Complement source |
| 14 | 1110 | DC=SC OR DC | OR |
| 6 | 0110 | DC=SC XOR DC | XOR |
| 15 | 1111 | DC=1 | Set all bits |

> *Source: OpenMSX `V9990CmdEngine` — `bitLUT` computed at compile time from `op & 0x0F`, iterating src/dst bits. The same 16-function truth table encoding as V9938/V9958. Note: unlike V9938 where operations 0-3 are "T-operations" and 8-11 are normal, V9990 uses a uniform 4-bit truth table for all 16.*

**TP (Transparent) bit** (R#45, bit 4): When TP=1, source pixels equal to 0 are not written — the destination pixel is preserved. The exact transparency granularity depends on the colour depth (per-pixel in 8/16bpp, per-sub-pixel in 2/4bpp).

> *Source: OpenMSX `getLogOpLUT()` — `(op & 0x10) ? Log::BPPn : Log::NO_T` selects TP-aware vs non-TP LUT.*

### Command Parameter Registers

Setting up a blit:

```
R#32-33: Source X (SX)     — 11-bit pixel coordinate
R#34-35: Source Y (SY)     — 12-bit pixel coordinate
R#36-37: Destination X (DX)
R#38-39: Destination Y (DY)
R#40-41: Width (NX)        — 11-bit pixel count
R#42-43: Height (NY)       — 12-bit pixel count
R#44:    Argument           — direction flags (DIX, DIY), VRAM page (MXS, MXD)
R#45:    Logical operation  — AND/OR/XOR/NOT + TP flag
R#46-47: Write mask         — per-bit write protection
R#48-49: Foreground colour  — for CMMC/CMMK/CMMM commands
R#50-51: Background colour  — for CMMC/CMMK/CMMM commands
R#52:    Opcode             — triggers execution on write
```

### Command Data Transfer (LMMC/CMMC)

For CPU-to-VRAM transfer commands, the CPU feeds pixel data through **P#2** (Command Data port). The V9990 signals readiness via the **TR** (Transfer Ready) bit in the Status register (P#5, bit 7) or via the *DREQ pin.

### Execution Flow

```z80
; Example: LMMV (fill rectangle at DX=100, DY=50, 64×32 pixels with colour &FF)
; Assumes 4bpp bitmap mode (Bpp4)
    ld a, 4         ; Select R#36 (DX low, auto-increment on)
    out (P4), a
    ld a, 100       ; DX low
    out (P3), a
    ld a, 0         ; DX high  (auto-inc to R#37)
    out (P3), a
    ld a, 50        ; DY low   (R#38)
    out (P3), a
    ld a, 0         ; DY high  (R#39)
    out (P3), a
    ld a, 64        ; NX low   (R#40)
    out (P3), a
    ld a, 0         ; NX high  (R#41)
    out (P3), a
    ld a, 32        ; NY low   (R#42)
    out (P3), a
    ld a, 0         ; NY high  (R#43)
    out (P3), a
    ld a, 0         ; ARG: no direction flags (R#44)
    out (P3), a
    ld a, &0A       ; LogOp: &0A = direct copy, TP=0 (R#45)
    out (P3), a
    ld a, &FF       ; Write mask low  (R#46)
    out (P3), a
    ld a, &FF       ; Write mask high (R#47)
    out (P3), a
    ld a, &FF       ; FC0 = fill colour low  (R#48)
    out (P3), a
    ld a, 0         ; FC1 = fill colour high (R#49, for 16bpp)
    out (P3), a
    ; Skip BC0/BC1 for LMMV
    ld a, &34       ; Select R#52 (opcode register), inhibit auto-inc
    out (P4), a
    ld a, &32       ; CMD: low nibble 2 = LMMV, high nibble 3 = Bpp4
    out (P3), a     ; Execution starts immediately
```

> *Source: R#52 encoding verified against OpenMSX `setCmdReg` dispatch. `&32` = high nibble 3 (Bpp4 pixel format) + low nibble 2 (LMMV command). LogOp `&0A` = truth table 1010 = DC:=SC (direct copy).*

---

## 9. Sprite System

Sprites are only available in **P1** and **P2** pattern modes.

### Sprite Attributes (in VRAM)

Each sprite uses 4 bytes in the Sprite Attribute Table:

| Byte | Bits | Field |
|------|------|-------|
| 0 | 7-0 | Y position (0-255; value 216 hides sprite and all lower-priority sprites) |
| 1 | 7-0 | Pattern number (0-255) |
| 2 | 7-4: palette, 3: P, 2-1: unused, 0: X bit 8 | Palette select (0-3), Priority, X MSB |
| 3 | 7-0 | X position bits 7-0 |

> *⚠ Note: Sprite attribute byte format above follows V9938/V9958 convention and OpenMSX implementation structure. Not yet verified against V9990 Application Manual §9 (sprite chapter not available as screenshot). Treat with caution until primary-source verification.*

### Sprite Properties

- **Size**: 16×16 dots, fixed
- **Per screen**: 125 maximum
- **Per scanline**: 16 maximum (excess sprites not drawn)
- **Colours**: 15 + transparent per sprite, from one of 4 palettes (16 colours each)
- **Pattern data**: 4 bits per pixel, selected from 256 patterns
- **Priority**: Sprite number determines priority (lower = higher priority). Each sprite has a P bit for priority vs. the pattern screen.
- **Pattern base**: Set by R#25. In P1 mode: `(R#25 & 0x0E) << 14`. In P2 mode: `(R#25 & 0x0F) << 15`. *(Source: OpenMSX `getSpritePatternAddress()`)*
- **Sprite palette offset**: `R#28 << 2` — shifts palette base for all sprites. *(Source: OpenMSX `getSpritePaletteOffset()`)*

---

## 10. Scroll System

### P1 Mode: Dual-Screen Independent Scroll

P1 mode provides two independent pattern screens (A and B) with separate scroll registers.

> *Scroll formulas confirmed by OpenMSX: `getScrollAX() = regs[AX0] + 8 * regs[AX1]`, `getScrollAY() = regs[AY0] + 256 * scrollAYHigh` (high byte latched at frame start). Same pattern for B registers.*

| Register | Screen | Direction | Range |
|----------|--------|-----------|-------|
| R#19-20 (AX0-AX1) | A | Horizontal | 0-2047 pixels |
| R#17-18 (AY0-AY1) | A | Vertical | 0-511 pixels (with roll mask) |
| R#23-24 (BX0-BX1) | B | Horizontal | 0-2047 pixels |
| R#21-22 (BY0-BY1) | B | Vertical | 0-511 pixels |

### Roll Mask (R#18, bits 7-6)

Controls the vertical wrapping boundary for Screen A:

| Value | Mask | Effect |
|-------|------|--------|
| 00 | maxMask | Full image height (no wrap within image) |
| 01 | 0x00FF | Wrap at 256 lines |
| 10 | 0x01FF | Wrap at 512 lines |
| 11 | 0x00FF | (Undocumented, same as 01?) |

### Bitmap Modes: Single-Screen Scroll

Bitmap modes use only the Screen A scroll registers. The image can be larger than the display (up to 2048×2048 at 2bpp), providing a scrollable viewport.

### Priority Control (R#27)

In P1 mode, the display can be split into quadrants with different screen A/B priority ordering:

```
b3  b2 │ b1  b0
  PYC  │  PXC
       │
       └─ X split position: 0=256 (no split), 1=64, 2=128, 3=192
  Y split position: 0=256 (no split), 1=64, 2=128, 3=192
```

Above/left of the split point: Screen A on top. Below/right: Screen B on top.

---

## 11. Interrupt System

The V9990 has three interrupt sources, reported through P#6 (Interrupt Flag) and two physical pins (*INT0, *INT1):

> *Source: OpenMSX `IRQType` enum: `VER_IRQ=1, HOR_IRQ=2, CMD_IRQ=4`. Pin mapping from datasheet §7.*

| Bit | Name | Pin | Trigger |
|-----|------|-----|---------|
| 0 | VI (Vertical Interval) | *INT0 | Start of vertical blanking |
| 1 | HI (Horizontal Interval) | *INT1 | Display reaches line set in R#9-R#10 |
| 2 | CE (Command End) | *INT0 | Blitter command finishes execution |

### Interrupt Enable (R#11)

Each interrupt can be individually enabled:

```
R#11: b2=CE enable, b1=HI enable, b0=VI enable
```

### Interrupt Acknowledge

Reading P#6 returns the pending interrupt flags. Writing P#6 **clears** the corresponding bits (write-1-to-clear). The IRQ pin deasserts when no enabled pending interrupts remain.

> *Source: OpenMSX `writeIO(INTERRUPT_FLAG)` — `pendingIRQs &= ~val` (bitwise clear). Then `if (!(pendingIRQs & regs[INTERRUPT_0])) irq.reset()`.*

```z80
; Interrupt handler for V9990
    in a, (P6)         ; Read interrupt flags
    bit 0, a           ; Check VBLANK
    jr z, .no_vblank
    ld a, 1
    out (P6), a        ; Clear VBLANK flag
    ; ... do vblank work ...
.no_vblank:
```

---

## 12. Status Register (P#5)

| Bit | Name | Function |
|-----|------|----------|
| 7 | TR | Transfer Ready — command engine ready for next data byte |
| 6 | VR | Vertical non-display — 1 during vertical blanking |
| 5 | HR | Horizontal non-display — 1 during horizontal blanking |
| 4 | BD | Border detect — SRCH command found boundary |
| 3 | — | Reserved |
| 2 | MCS | Master Clock Select — reflects P#7 bit 0 (0=XTAL, 1=MCKIN) |
| 1 | EO | Even/Odd field — toggles each frame (for interlace) |
| 0 | CE | Command Execute — 1 while command engine is busy |

> *Source: OpenMSX `peekIO(STATUS)` — VR/HR computed from timing position, CE/TR from cmdEngine. Bit 2 (MCS) set by `writeIO(SYSTEM_CONTROL)`: `status = (status & 0xFB) | ((val & 1) << 2)`. Bit 1 (EO) toggled at `frameStart()`: `status ^= 0x02`.*

---

## 13. Video Memory Configuration

The V9990 supports three VRAM sizes using dual-port DRAM:

| Configuration | Chips | Access time |
|---------------|-------|-------------|
| 128 KB | 64k×4bit × 4 | 120ns (100ns for B6) |
| 256 KB | 128k×8bit × 2 | 120ns (100ns for B6) |
| 512 KB | 256k×4bit × 4 | 120ns (100ns for B6) |

Plus an optional 2Mbit (256KB) **Kanji ROM** for 16×16 JIS character fonts.

### VRAM Layout in Pattern Modes

```
P1 mode with 512KB VRAM:
  ┌─────────────────────┐
  │ Pattern Name Tables  │  Screen A + Screen B (tile map)
  │ (variable position)  │
  ├─────────────────────┤
  │ Pattern Generator    │  Up to 15,359 unique 8×8 tiles
  │ (tile graphics)      │
  ├─────────────────────┤
  │ Sprite Attribute Tbl │  125 sprites × 4 bytes
  ├─────────────────────┤
  │ Sprite Pattern Gen   │  256 patterns × 128 bytes (16×16 @ 4bpp)
  └─────────────────────┘
```

### VRAM Layout in Bitmap Modes

Bitmap VRAM is linear — pixel (X,Y) maps to address `Y × image_width_bytes + X × bytes_per_pixel`. The image size can exceed the display size, creating a virtual screen that scrolls.

---

## 14. Clock System

```
XTAL (21.4772 MHz) ──► Internal dividers ──► DHCLK (÷2 = 10.7 MHz)
                                          ──► DLCLK (÷4 = 5.37 MHz)

Alternative: MCKIN (14.318 MHz) ──► ÷2 = 7.16 MHz
                                ──► ÷4 = 3.58 MHz
```

### Dot Clock per Mode

| Mode | Master Clock | Dot Clock | Pixels per MCLK tick |
|------|-------------|-----------|---------------------|
| P1 | 21.5 MHz | 5.4 MHz | 1/4 |
| P2 | 21.5 MHz | 10.7 MHz | 1/2 |
| B1 | 21.5 MHz | 5.4 MHz | 1/4 |
| B2 | 14.3 MHz | 7.2 MHz | 1/2 |
| B3 | 21.5 MHz | 10.7 MHz | 1/2 |
| B4 | 14.3 MHz | 14.3 MHz | 1/1 |
| B5 | 21.5 MHz | 21.5 MHz | 1/1 |
| B6 | 25.2 MHz | 25.2 MHz | 1/1 |

---

## 15. CPC Integration: The GFX-NINE Card

### How It Connects

The TMTLogic **GFX-NINE** is a CPC expansion card that mounts the V9990 on the CPC's expansion bus. The card:

1. **Decodes a 16-port I/O range** in the CPC's expansion space (likely &FDxx, adjacent to the Symbiface 3's &FD40-&FD4F range)
2. Maps CPC address lines A0-A3 to V9990 MODE3-0 pins (port select)
3. Connects CPC data bus D7-0 to V9990 CD7-0
4. Generates *CSR/*CSW from CPC *IORQ + *RD/*WR signals
5. Routes *WAIT back to the CPC Z80's WAIT pin for bus synchronisation
6. Routes *INT0/*INT1 to the CPC's interrupt chain (active low, accent)
7. Provides separate RGB output (V9990's built-in DAC drives its own monitor connector)
8. Carries its own VRAM chips (128-512KB) and crystal oscillator

### I/O Port Mapping (CPC)

The exact port decode depends on the GFX-NINE hardware design. Following the TMTLogic convention (Symbiface 3 uses &FD40-&FD4F):

| CPC Port | V9990 Port | Function |
|----------|------------|----------|
| Base+0 | P#0 | VRAM Data |
| Base+1 | P#1 | Palette Data |
| Base+2 | P#2 | Command Data |
| Base+3 | P#3 | Register Data |
| Base+4 | P#4 | Register Select |
| Base+5 | P#5 | Status |
| Base+6 | P#6 | Interrupt Flag |
| Base+7 | P#7 | System Control |
| Base+8 | P#8 | Kanji ROM Low |
| Base+9 | P#9 | Kanji ROM Data |
| Base+A | P#A | Kanji ROM Low 2 |
| Base+B | P#B | Kanji ROM Data 2 |
| Base+C-F | P#C-F | Reserved |

### Dual-Monitor Setup

The V9990's RGB output is independent of the CPC's native video. This creates a **dual-monitor** configuration:

```
                    ┌─────────────┐
  CPC Gate Array ──►│  Monitor 1  │  CPC native display (Mode 0/1/2)
                    └─────────────┘

                    ┌─────────────┐
  V9990 DAC ──────►│  Monitor 2  │  V9990 display (P1/P2/Bx)
                    └─────────────┘
```

Some setups use **Video9000**-style superimposition where the V9990's YS signal allows mixing V9990 output with an external video source (in this case, the CPC's native output), but this requires additional external hardware.

### Software Model

From the Z80's perspective, using the V9990 is purely I/O port driven:

```z80
; CPC Z80 code to initialise V9990 in B3 mode (512×212, 4bpp)
V9990_BASE  equ &FD60          ; example port base (card-dependent)
P0          equ V9990_BASE+0   ; VRAM data
P1          equ V9990_BASE+1   ; Palette data
P3          equ V9990_BASE+3   ; Register data
P4          equ V9990_BASE+4   ; Register select
P5          equ V9990_BASE+5   ; Status
P6          equ V9990_BASE+6   ; Interrupt

    ; Reset V9990
    ld a, 2                     ; System reset
    out (V9990_BASE+7), a
    ; Wait for reset complete
    ld b, 0
.wait: djnz .wait

    ; Set R#6: B3 mode, DHCLK, 512 image width, 4bpp
    ;   DSPM=10 (Bx), DCKM=01 (DHCLK), XIMM=01 (512 image width), CLRM=01 (4bpp)
    ;   = 10_01_01_01 = &95
    ld a, 6                     ; Select R#6
    out (P4), a
    ld a, &95                   ; B3 mode: Bx bitmap, DHCLK dot clock, 512w, 4bpp
    out (P3), a

    ; Set R#7: NTSC, no interlace
    ld a, 0                     ; NTSC defaults
    out (P3), a                 ; R#7 (auto-incremented from R#6)

    ; Set R#8: Display ON, sprites off
    ld a, &C0                   ; DISP=1, SPD=1 (sprites disabled in Bx)
    out (P3), a                 ; R#8

    ; Set palette entry 0 = black, entry 1 = white
    ;   R#14 format: bits 7-2 = palette entry, bits 1-0 = RGB counter (0=R)
    ld a, 14                    ; Select R#14 (Palette Pointer)
    out (P4), a
    ld a, 0                     ; Entry 0, R counter = 0
    out (P3), a
    ; Now write palette via P#1
    xor a
    out (P1), a                 ; R=0
    out (P1), a                 ; G=0
    out (P1), a                 ; B=0 (black)
    ld a, 31
    out (P1), a                 ; R=31
    out (P1), a                 ; G=31
    out (P1), a                 ; B=31 (white)
```

---

## 16. Emulation Architecture (konCePCja)

### Design Overview

The V9990 is architecturally independent from the CPC's native video — it has its own VRAM, its own timing, and its own display output. This makes it a relatively clean addition to the emulator.

```
┌─────────────────────────────────────────────────────┐
│                   konCePCja                          │
│                                                      │
│  ┌──────────────┐    ┌──────────────┐               │
│  │   z80.cpp    │    │   crtc.cpp   │               │
│  │ (Z80 CPU)    │    │ (Gate Array) │               │
│  │              │    │ (native CPC  │               │
│  │  OUT handler─┤    │   video)     │               │
│  │  IN handler ─┤    └──────┬───────┘               │
│  └──────┬───────┘           │                        │
│         │                   ▼                        │
│         │           ┌──────────────┐  CPC texture   │
│         │           │  video.cpp   │────────────►    │
│         │           └──────────────┘              ┌──┤
│         │                                         │  │
│         │  I/O ports                              │  │
│         ├──────────►┌──────────────┐              │  │
│         │           │  v9990.cpp   │  V9990 texture│  │
│         │           │  (NEW)       │────────────►  │  │
│         │           │              │              │  │
│         │           │  ┌─ VRAM[]   │         Dear │  │
│         │           │  ├─ regs[]   │         ImGui│  │
│         │           │  ├─ palette[]│         comp-│  │
│         │           │  ├─ cmdeng   │         osite│  │
│         │           │  └─ framebuf │              │  │
│         │           └──────────────┘              │  │
│         │                                         └──┤
│         │                                            │
└─────────┴────────────────────────────────────────────┘
```

### Key Components

#### 1. `v9990.h` / `v9990.cpp` — Core VDP Emulation

```cpp
struct V9990 {
    // VRAM
    std::vector<uint8_t> vram;  // 128KB, 256KB, or 512KB
    unsigned vram_size;

    // Registers
    uint8_t regs[64];          // R#0-R#28, R#32-R#54
    uint8_t reg_select;        // Current register pointer

    // VRAM address pointers
    unsigned vram_write_ptr;
    unsigned vram_read_ptr;
    uint8_t vram_read_buffer;  // Pre-fetch buffer

    // Palette
    uint8_t palette[256];      // 64 entries × 4 bytes (R,G,B,0), addressed by R#14
    uint8_t palette_ptr;       // Auto-cycling R→G→B counter (skips every 4th byte)

    // Status
    uint8_t status;            // P#5 register
    uint8_t pending_irqs;      // Interrupt flags

    // Display state
    V9990DisplayMode mode;
    bool display_enabled;
    bool pal_timing;
    bool interlaced;

    // Command engine state
    V9990CmdEngine cmd_engine;

    // Frame buffer (rendered output)
    uint32_t framebuffer[1024 * 512];  // RGBA pixels for display

    // I/O interface
    uint8_t read_port(uint8_t port);
    void write_port(uint8_t port, uint8_t value);

    // Per-frame rendering
    void render_frame();

    // Reset
    void reset();
};
```

#### 2. `v9990_cmd.h` / `v9990_cmd.cpp` — Command Engine

The command engine is the most complex part. It must:
- Parse command parameters from R#32-R#54
- Execute 15 different commands with pixel-level precision
- Handle all logical operations (AND/OR/XOR/NOT/TP)
- Work in coordinate space (X,Y) with the correct pixel pitch for the current display mode
- Support both directions (left-right, right-left, top-bottom, bottom-top)
- Operate asynchronously (the CPC continues running while the blitter works)

#### 3. I/O Port Hooks in `kon_cpc_ja.cpp`

```cpp
// In z80_OUT_handler():
if ((port & 0xFFF0) == V9990_IO_BASE) {
    g_v9990.write_port(port & 0x0F, val);
    return;
}

// In z80_IN_handler():
if ((port & 0xFFF0) == V9990_IO_BASE) {
    return g_v9990.read_port(port & 0x0F);
}
```

#### 4. Display Output

The V9990's output is a separate texture from the CPC's native display. In the ImGui interface, this could be shown as:
- A separate "V9990 Display" window
- A picture-in-picture overlay
- A composited view (if superimposition is implemented)

#### 5. Timing Synchronisation

The V9990 has its own display timing (NTSC 15.7KHz / PAL, or 25.3KHz/31.5KHz for OA modes). For emulation:
- Track V9990 scanline position relative to CPC frame timing
- Fire VI interrupt at V9990's own vertical blanking
- Fire HI interrupt at the configured scanline
- Render V9990 output once per V9990 frame (which may differ from CPC frame rate)

### Phased Implementation

#### Phase 1: Registers + VRAM access
- Port decode (P#0-P#7)
- Register read/write with auto-increment
- VRAM read/write with address auto-increment
- Basic status register
- DevTools window showing V9990 register state

#### Phase 2: Bitmap display
- B1 mode (256×212) — simplest bitmap mode
- Colour modes: BP4, BP6, BD8
- Palette system
- Render to SDL texture
- ImGui "V9990 Display" window

#### Phase 3: Pattern display
- P1 mode (dual-screen scroll)
- P2 mode (hi-res single screen)
- Pattern name tables + pattern generators
- Sprite rendering (16×16, 125 per screen)

#### Phase 4: Command engine
- LMMV (fill) — easiest command
- LMMM (copy) — essential for games
- LMMC (CPU→VRAM transfer)
- LINE (Bresenham drawing)
- Remaining commands (CMMC, CMMK, CMMM, BMXL, BMLX, BMLL, SRCH, POINT, PSET, ADVANCE)
- Logical operations
- Asynchronous execution with timing

#### Phase 5: Advanced features
- Interlace
- Overscan modes (B0, B2, B4)
- YUV/YJK colour modes
- Superimposition (YS flag)
- Kanji ROM
- High-resolution modes (B5, B6)

---

## 17. Comparison with Other VDPs

| Feature | V9938 (MSX2) | V9958 (MSX2+) | V9990 |
|---------|-------------|---------------|-------|
| Year | 1985 | 1988 | 1992 |
| Max resolution | 512×212 | 512×212 | 768×480 |
| Max colours | 256 from 512 | 19,268 (YJK) | 32,768 |
| Palette entries | 16 | 16 | 64 |
| VRAM | 128KB | 128KB | 512KB |
| Sprites | 32 (8/line) | 32 (8/line) | 125 (16/line) |
| Pattern screens | 1 | 1 | 2 (P1) |
| Hardware scroll | 1 direction | 2 directions | Omnidirectional × 2 |
| Blitter | Yes (15 cmds) | Yes (15 cmds) | Yes (15 cmds, faster) |
| Register access | Indirect | Indirect | Auto-increment burst |
| Colour bus | 4-bit | 4-bit | 8-bit |
| Superimpose | External | External | Built-in YS |

### Comparison with CPC Plus ASIC

| Feature | CPC Plus ASIC | V9990 |
|---------|--------------|-------|
| Sprites | 16 (16×16, 15 colours) | 125 (16×16, 15 colours) |
| Sprite magnification | 2×, 4× | None |
| DMA sound | 3 channels, 5KHz | None (video only) |
| Palette | 4096 colours (12-bit) | 32,768 colours (15-bit) |
| Hardware scroll | Pixel-level (CRTC tricks) | Native register-based |
| Blitter | None | 15 hardware commands |
| Independent timing | No (shares CRTC) | Yes (own crystal + CRTC) |

---

## 18. Reference Implementation: OpenMSX

The most complete open-source V9990 emulation is in [OpenMSX](https://github.com/openMSX/openMSX). Key source files:

| File | Purpose |
|------|---------|
| `V9990.hh` / `V9990.cc` | Core VDP: registers, I/O ports, timing, interrupts |
| `V9990VRAM.hh` / `V9990VRAM.cc` | VRAM access with read/write pointers |
| `V9990CmdEngine.hh` / `V9990CmdEngine.cc` | All 15 hardware commands |
| `V9990ModeEnum.hh` | Display mode definitions |
| `V9990DisplayTiming.hh` | NTSC/PAL timing constants |
| `V9990PixelRenderer.hh` / .cc | Renders V9990 display to host framebuffer |
| `V9990P1Converter.hh` / .cc | P1 mode rendering (dual-screen patterns) |
| `V9990P2Converter.hh` / .cc | P2 mode rendering |
| `V9990BitmapConverter.hh` / .cc | Bitmap mode rendering |

### OpenMSX Port Enum (from V9990.hh)

```cpp
enum PortId : uint8_t {
    VRAM_DATA = 0,      // P#0
    PALETTE_DATA,       // P#1
    COMMAND_DATA,       // P#2
    REGISTER_DATA,      // P#3
    REGISTER_SELECT,    // P#4
    STATUS,             // P#5
    INTERRUPT_FLAG,     // P#6
    SYSTEM_CONTROL,     // P#7
    KANJI_ROM_0,        // P#8
    KANJI_ROM_1,        // P#9
    KANJI_ROM_2,        // P#A
    KANJI_ROM_3,        // P#B
    RESERVED_0..3       // P#C-P#F
};
```

### OpenMSX Register Enum (from V9990.hh)

```cpp
enum RegisterId : uint8_t {
    VRAM_WRITE_ADDRESS_0 = 0,  // R#0
    VRAM_WRITE_ADDRESS_1,      // R#1
    VRAM_WRITE_ADDRESS_2,      // R#2
    VRAM_READ_ADDRESS_0,       // R#3
    VRAM_READ_ADDRESS_1,       // R#4
    VRAM_READ_ADDRESS_2,       // R#5
    SCREEN_MODE_0,             // R#6
    SCREEN_MODE_1,             // R#7
    CONTROL,                   // R#8
    INTERRUPT_0,               // R#9
    INTERRUPT_1,               // R#10
    INTERRUPT_2,               // R#11
    INTERRUPT_3,               // R#12
    PALETTE_CONTROL,           // R#13
    PALETTE_POINTER,           // R#14
    BACK_DROP_COLOR,           // R#15
    DISPLAY_ADJUST,            // R#16
    SCROLL_CONTROL_AY0..AY1,   // R#17-18
    SCROLL_CONTROL_AX0..AX1,   // R#19-20
    SCROLL_CONTROL_BY0..BY1,   // R#21-22
    SCROLL_CONTROL_BX0..BX1,   // R#23-24
    SPRITE_PATTERN_ADDRESS,    // R#25
    LCD_CONTROL,               // R#26
    PRIORITY_CONTROL,          // R#27
    SPRITE_PALETTE_CONTROL,    // R#28
    // Gap: R#29-R#31 unused
    CMD_PARAM_SRC_ADDRESS_0 = 32,  // R#32
    // ... through R#54
    CMD_PARAM_OPCODE = 52,     // R#52 (triggers command on write)
};
```

---

## 19. Kanji ROM Interface

The V9990 can directly drive an external Kanji ROM (2Mbit, 16×16 dot JIS characters). This is accessed through P#8-P#B:

### Primary Kanji (JIS Level 1)

```
1. Write P#9: upper 6 bits of font address
2. Write P#8: lower 6 bits of font address
3. Read P#9: 32 times to get the full 16×16 character (4 quadrants × 8 bytes each)
```

### Font Data Layout

Each 16×16 character is stored as four 8×8 quadrants:
```
 ┌────┬────┐
 │ 1st│ 2nd│   Each quadrant: 8 bytes (1 bit per pixel, 8 pixels per byte)
 │8 B │8 B │   Total: 32 bytes per character
 ├────┼────┤
 │ 3rd│ 4th│
 │8 B │8 B │
 └────┴────┘
    16 dots horizontal × 16 dots vertical
```

---

## 20. Superimposition

The V9990 supports video superimposition through the **YS** (Y-Signal) mechanism:

1. **R#8 bit 5 (YSE)**: Global superimposition enable
2. **Palette bit 7 (YS per entry)**: Each palette colour's RED byte bit 7 can be set to make that colour "transparent to external video"
3. **External video source**: Must be present (hardware signal to V9990)
4. **Physical pin *YS**: Active low when the V9990 wants the external video to show through

A pixel is superimposed (shows external video instead) only when ALL three conditions are true: R#8 YSE is set, an external video source is connected, AND the palette entry's YS bit (RED byte bit 7) is set.

> *Source: OpenMSX `getPalette()` — `bool ys = isSuperimposing() && (palette[4*index+0] & 0x80)`. The `isSuperimposing()` check combines R#8 bit 5 (`regs[CONTROL] & 0x20`) with `externalVideoSource` flag. This logic is evaluated per-frame at frame start.*

This allows mixing V9990 graphics with another video source — on MSX this is used with Video9000 to overlay V9990 graphics on top of the native VDP output. On the CPC, it could theoretically overlay V9990 graphics on the Gate Array's output with appropriate external mixing hardware.

---

## Sources and Verification Status

### Primary Sources

- **Yamaha V9990 Application Manual** (LSI-2499903), September 1992 — scanned PDF, pages 1-14 available as screenshots
- **OpenMSX source code** (`src/video/v9990/`): V9990.hh, V9990.cc, V9990CmdEngine.cc — most complete open-source V9990 emulation, tested against real hardware
- CPC Wiki: RSF3, Symbiface 3 pages
- MSX Wiki: Category:V9990, GFX9000, Tecnobytes V9990 Powergraph

### Verification Cross-Reference

Items marked with source annotations throughout the document have been verified against at least one primary source. Summary of verification status:

| Section | Status | Source |
|---------|--------|--------|
| I/O Port Map (P#0-P#F) | **Verified** | Datasheet §7 + OpenMSX PortId enum |
| Register Map (R#0-R#54) | **Verified** | OpenMSX RegisterId enum + regAccess[] |
| R#6 Screen Mode fields | **Verified** | OpenMSX getColorDepth, getImageWidth, calcDisplayMode |
| R#8 Control bits | **Verified** | OpenMSX spritesEnabled (`& 0x40`), displayEnabled (`& 0x80`) |
| R#52 Command format | **Verified** | OpenMSX setCmdReg dispatch (bits 3-0 = cmd, 7-4 = pixel fmt) |
| Palette format (YS=bit 7) | **Verified** | OpenMSX getPalette (`& 0x80`), writePaletteRegister (`& 0x9F`) |
| Palette 4-byte stride | **Verified** | OpenMSX palette init + R→G→B counter (`palPtr += 2` on blue) |
| Colour mode selection | **Verified** | OpenMSX getColorMode switch |
| Display modes B0-B7 | **Verified** | OpenMSX calcDisplayMode (MCLK/XTAL × DCKM) |
| Scroll registers | **Verified** | OpenMSX getScrollAX/AY/BX/BY |
| Priority control R#27 | **Verified** | OpenMSX getPriorityControlX/Y |
| IRQ types | **Verified** | OpenMSX IRQType enum (VER=1, HOR=2, CMD=4) |
| IRQ acknowledge (write-1-clear) | **Verified** | OpenMSX writeIO(INTERRUPT_FLAG) |
| Status register bits | **Verified** | OpenMSX peekIO(STATUS), bit 2 = MCS |
| Sprite pattern address | **Verified** | OpenMSX getSpritePatternAddress |
| Sprite palette offset | **Verified** | OpenMSX getSpritePaletteOffset |
| VRAM access protocol | **Verified** | Datasheet §7 + OpenMSX writeIO/readIO(VRAM_DATA) |
| Pin 113 (CD0 / MCKIN) | **⚠ CONFLICT** | Transcription error — one pin number is wrong, needs re-check from datasheet pinout diagram |
| Sprite attribute byte format | **⚠ Unverified** | Based on V9938 convention, not confirmed from V9990 datasheet §9 |
| Command timing tables | **⚠ Partial** | Opcode dispatch verified, detailed tick timing from OpenMSX (some marked TODO in their source) |
